#!/usr/bin/env python3
import os
import sys
import shutil
import argparse
from templates import *
from pathlib import Path

# Get the absolute path to the folder containing this script
MAIN_DIR = Path(__file__).resolve().parent

# Always run as if the current working directory were this script's folder
os.chdir(MAIN_DIR)

# Ensure the project root is in sys.path (for imports like `acsl_pychrono.executor`)
if str(MAIN_DIR.parent) not in sys.path:
  sys.path.insert(0, str(MAIN_DIR.parent))

# ---------------------------------------------------------------------
# Default Template Configs
# ---------------------------------------------------------------------
DEFAULT_UAV = "X8"
TEMPLATE_CONFIGS = {
    "X8": "templates/X8/x8_config.yaml",
    "QUAD": "templates/QUAD/quad_config.yaml"
}
TEMPLATE_CLASS_FILES = {
    "X8": "templates/X8/x8.py",
    "QUAD": "templates/QUAD/quad.py"
}
TEMPLATE_GAINS_FILE = {
    "X8": "templates/X8/Controller_Gains",
    "QUAD": "templates/QUAD/Controller_Gains"
}
TEMPLATE_CHRONO_PY_FILE = {
    "X8": "templates/X8/CAD_export/x8copter.py",
    "QUAD": "templates/QUAD/CAD_export/QUAD_export.py"
}
TEMPLATE_SHAPES_FOLDER = {
    "X8": "templates/X8/CAD_export/shapes",
    "QUAD": "templates/QUAD/CAD_export/shapes"
}

# ---------------------------------------------------------------------
# File Templates
# ---------------------------------------------------------------------
INIT_TEMPLATE = """\
# acsl_pychrono/uav/{uav_name}/__init__.py
from .{uav_name} import UAV_INSTANCE
"""

UAV_CLASS_TEMPLATE = """\
import numpy as np
from pathlib import Path
import acsl_pychrono.uav as UAV_module
from acsl_pychrono.uav.uav_parent_class_file import UAV_PARENT_CLASS as UAV

class UAV_INSTANCE(UAV):
    def __init__(self):
    # --------------------------------------------------------------------------------------------------------
    # No need to change anything here
    # --------------------------------------------------------------------------------------------------------
    super().__init__()
    
    # Get the UAV name from the class name
    self.name = Path(__file__).stem
    
    # UAV specific parameters
    cfg = UAV_module.get_uav_config(self.name) # Config Dictionary
    
    self.loadFromYAML(cfg)  # Load generic parameters
    
    # --- UAV-specific ---
    self._load_inertia()
    self._compute_mixer_matrix(cfg)
    
    def _load_inertia(self):
        # --------------------------------------------------------------------------------------------------------
        # If the UAV CAD model is designed in SolidWorks with the yup convention, no need to change anything here
        # Otherwise, modify this function accordingly
        # --------------------------------------------------------------------------------------------------------
        # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
        # Since the inertia_matrix_untransformed was obtained in the Solidworks coordinate sys (yup), it needs to be transformed to (ned)
        self.Inertia_mat_pixhawk = self.RotMat_X_PI_2_array @ self.inertia_matrix_untransformed @ self.RotMat_X_PI_2_tran_array  
        
    def _compute_mixer_matrix(self, cfg):
        # --------------------------------------------------------------------------------------------------------
        # Must change according to the UAV geometry configuration
        # --------------------------------------------------------------------------------------------------------
        # Mixer Matrix for the realization of the thrust generated by each motor
        # (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
        l_x = float(cfg["uav"]["mixer_matrix"]["l_x"])
        l_y = float(cfg["uav"]["mixer_matrix"]["l_y"])
        c_t = float(cfg["uav"]["mixer_matrix"]["c_t"])

        # Mixer matrix for QUADcopter 
        # U_mat = np.array([[   1,    1,    1,    1 ], 
        #                   [ l_y,   l_y, -l_y, -l_y],
        #                   [-l_x,   l_x,  l_x, -l_x],
        #                   [-c_t,   c_t, -c_t,  c_t]])

        # Moore-Penrose pseudo-inverse of X8copter mixer matrix
        self.U_mat_inv = np.array([
        [1/4,  1/(4*l_y),  1/(4*l_x),  1/(4*c_t)],
        [1/4, -1/(4*l_y),  1/(4*l_x), -1/(4*c_t)],
        [1/4, -1/(4*l_y), -1/(4*l_x),  1/(4*c_t)],
        [1/4,  1/(4*l_y), -1/(4*l_x), -1/(4*c_t)]
        ])
"""

PID_TEMPLATE = """\
# Example PID gains
P: 0.1
I: 0.01
D: 0.005
"""

MRAC_TEMPLATE = """\
# Example MRAC controller gains
adaptation_rate: 0.05
reference_model: simple
"""

TWOLAYER_TEMPLATE = """\
# Example Two-Layer MRAC configuration
inner_layer:
  adaptation_rate: 0.1
outer_layer:
  learning_rate: 0.05
"""

PLACEHOLDER_OBJ = """\
# Placeholder OBJ content ‚Äî replace with real exported meshes.
o Placeholder
v 0.0 0.0 0.0
"""

PLACEHOLDER_SOLIDWORKS = """\
# Placeholder PyChrono-SolidWorks export
import pychrono as chrono
def create_exported_uav(system):
    print("This is a placeholder UAV export.")
"""

# ---------------------------------------------------------------------
# UAV Creator
# ---------------------------------------------------------------------
def create_uav_structure(
    base_dir,
    assets_dir,
    uav_name,
    config_path=None,
    shapes_path=None,
    uav_py_path=None,
    uav_chrono_py_path=None,
    gains_folder=None,
    template=DEFAULT_UAV,
):
    # uav_name_upper = uav_name.upper()
    uav_dir = Path(base_dir) / uav_name

    # === Check for duplicate name ===
    if uav_dir.exists():
        print(f"[ERROR] UAV '{uav_name}' already exists at {uav_dir}")
        print("[WARNING] Please choose a different name or use --uav_rename to rename an existing UAV.")
        sys.exit(1)

    controller_gains_dir = uav_dir / "Controller_Gains"
    uav_dir.mkdir(parents=True, exist_ok=True)
    controller_gains_dir.mkdir(exist_ok=True)

    # === Write __init__.py ===
    (uav_dir / "__init__.py").write_text(INIT_TEMPLATE.format(uav_name=uav_name))

    # === Config file ===
    cfg_dest = uav_dir / f"{uav_name}_config.yaml"
    # print(cfg_dest, "***************************************************")
    if config_path and Path(config_path).exists():
        # print(f"[INFO] Copying config from {config_path}")
        shutil.copy(config_path, cfg_dest)
    else:
        print(f"[INFO] No config file provided ‚Äî using {template} template.")
        template_config_path = Path(TEMPLATE_CONFIGS.get(template, TEMPLATE_CONFIGS[DEFAULT_UAV]))
        if template_config_path.exists():
            shutil.copy(template_config_path, cfg_dest)
        else:
            cfg_dest.write_text(f"# Placeholder config for {uav_name}\nuav:\n  name: {uav_name}\n")
            
    # BROKEN! no uav.name anymore
    # old_name = get_yaml_value(cfg_dest, "uav.name")
    # replace_in_file(cfg_dest, old_str=old_name, new_str=uav_name)
    # replace_in_file(cfg_dest, old_str=f"{old_name}_export.py", new_str=f"{uav_name}_export.py")
    # update_yaml_value_preserve_comments(cfg_dest, "uav.name", uav_name)
    # update_yaml_value_preserve_comments(cfg_dest, "uav.cad.export_filename", f"{uav_name}_export.py")

    # === UAV Python class ===
    uav_py_dest = uav_dir / f"{uav_name}.py"
    if uav_py_path and Path(uav_py_path).exists():
        shutil.copy(uav_py_path, uav_py_dest)
    else:
        print(f"[INFO] No UAV class file provided ‚Äî using {template} template.")
        template_class_path = Path(TEMPLATE_CLASS_FILES.get(template, TEMPLATE_CLASS_FILES[DEFAULT_UAV]))
        # print(f"{template_class_path}, {uav_py_dest} ******************************")
        if template_class_path.exists():
            # print(f"[INFO] Copying config from {template_class_path} to {cfg_dest} ***********************")
            shutil.copy(template_class_path, uav_py_dest)
        else:
            uav_py_dest.write_text(UAV_CLASS_TEMPLATE.format(uav_name=uav_name))
        
    # Rename the python class inside the file
    # old_class_name = get_class_names_from_file(uav_py_dest)[0]
    # replace_in_file(uav_py_dest, old_str=old_class_name, new_str=uav_name)
    # rename_internal_references(uav_dir, "X8", uav_name, exts=(".py"))

    # === Controller gains ===
    if gains_folder and Path(gains_folder).exists():
        # print(f"[INFO] Copying gains from {gains_folder}")
        for file in Path(gains_folder).glob("*.yaml"):
            shutil.copy(file, controller_gains_dir / file.name)
    else:
        print(f"[INFO] No Controller Gains folder provided ‚Äî using {template} templates.")
        template_gains_folder_path = Path(TEMPLATE_GAINS_FILE.get(template, TEMPLATE_GAINS_FILE[DEFAULT_UAV]))
        if template_gains_folder_path.exists():
            for file in Path(template_gains_folder_path).glob("*.yaml"):
                shutil.copy(file, controller_gains_dir / file.name)
        else:
            print("[INFO] No gains folder provided ‚Äî using placeholder templates.")
            (controller_gains_dir / "PID.yaml").write_text(PID_TEMPLATE)
            (controller_gains_dir / "MRAC.yaml").write_text(MRAC_TEMPLATE)
            (controller_gains_dir / "TwoLayerMRAC.yaml").write_text(TWOLAYER_TEMPLATE)

    # === Assets ===
    vehicle_assets_dir = Path(assets_dir) / "vehicles" / uav_name
    vehicle_assets_dir.mkdir(parents=True, exist_ok=True)

    # --- CAD Export py file ---
    export_dest = vehicle_assets_dir / Path(get_yaml_value(cfg_dest, "uav.cad.pychono_export")).name #f"{uav_name}_export.py"
    if uav_chrono_py_path and Path(uav_chrono_py_path).exists():
        shutil.copy(uav_chrono_py_path, export_dest)
    else:
        print(f"[INFO] No pychrono export py file provided ‚Äî using {template} template.")
        template_chrono_py_path = Path(TEMPLATE_CHRONO_PY_FILE.get(template, TEMPLATE_CHRONO_PY_FILE[DEFAULT_UAV]))
        if template_chrono_py_path.exists():
            shutil.copy(template_chrono_py_path, export_dest)
        else:
            print("[INFO] No pychrono export py file provided ‚Äî using placeholder template.")
            (export_dest).write_text(PLACEHOLDER_SOLIDWORKS)
        
    # --- CAD Export shapes folder ---
    if shapes_path and Path(shapes_path).exists():
        dst_shapes = vehicle_assets_dir / Path(shapes_path).name
        shutil.copytree(shapes_path, dst_shapes, dirs_exist_ok=True)
    else:
        print(f"[INFO] No shapes folder provided ‚Äî using {template} template.")
        template_shapes_folder_path = Path(TEMPLATE_SHAPES_FOLDER.get(template, TEMPLATE_SHAPES_FOLDER[DEFAULT_UAV]))
        dst_shapes = vehicle_assets_dir / template_shapes_folder_path.name
        # print(f"{template_shapes_folder_path} ***********************")
        if template_shapes_folder_path.exists():
            shutil.copytree(template_shapes_folder_path, dst_shapes, dirs_exist_ok=True)
        else:
            print("[INFO] No shapes folder provided ‚Äî using placeholder template.")
            placeholder_shapes = vehicle_assets_dir / f"shapes"
            placeholder_shapes.mkdir(exist_ok=True)
            (placeholder_shapes / "placeholder.obj").write_text(PLACEHOLDER_OBJ)

    print("[INFO] UAV package created successfully!")
    print(f"[INFO] UAV module directory: {uav_dir}")
    print(f"[INFO] Assets directory: {vehicle_assets_dir}")
    return uav_dir
            
# ---------------------------------------------------------------------
# UAV Rename Functionality
# ---------------------------------------------------------------------
# TODO: Handle case sensitivity properly on all OSes
def rename_uav(base_dir, assets_dir, old_name, new_name):

    old_uav_dir = Path(base_dir) / old_name
    new_uav_dir = Path(base_dir) / new_name

    old_assets_dir = Path(assets_dir) / "vehicles" / old_name
    new_assets_dir = Path(assets_dir) / "vehicles" / new_name
    
    # new_cfg_dir = new_uav_dir / f"{new_name}_config.yaml"
    # new_py_dir = new_uav_dir / f"{new_name}.py"

    # Validate existence
    if not old_uav_dir.exists():
        print(f"[ERROR] UAV '{old_name}' does not exist at {old_uav_dir}")
        sys.exit(1)
    if new_uav_dir.exists():
        print(f"[WARNING] UAV '{new_name}' already exists. Choose a new name.")
        sys.exit(1)

    # Rename UAV folder
    shutil.move(str(old_uav_dir), str(new_uav_dir))
    rename_files(new_uav_dir, f"{old_name}_config.yaml", f"{new_name}_config.yaml")
    rename_files(new_uav_dir, f"{old_name}.py", f"{new_name}.py")
    replace_in_file(new_uav_dir / "__init__.py", f".{old_name}", f".{new_name}")
    delete_folder(new_uav_dir / "__pycache__", force=True)
    # rename_internal_references(new_uav_dir, old_name, new_name, exts=(".py"))
    
    # rename_internal_folders(new_uav_dir, old_name, new_name)

    # Rename internal references
    # replace_in_file(new_cfg_dir, old_name, new_name, use_regex=False)
    # replace_in_file(new_py_dir, f"{old_name}_export.py", f"{new_name}_export.py", use_regex=False)
    # update_yaml_value_preserve_comments(new_cfg_dir, "uav.name", new_name)
    # update_yaml_value_preserve_comments(new_cfg_dir, "uav.cad.export_filename", f"{new_name}_export.py")
    
    # old_class_name = get_class_names_from_file(uav_py_dest)[0]
    # replace_in_file(new_uav_dir, old_str=old_name, new_str=new_name)

    # Rename assets
    if old_assets_dir.exists():
        shutil.move(str(old_assets_dir), str(new_assets_dir))
    # rename_files(new_assets_dir, f"{old_name}_export.py", f"{new_name}_export.py")
    delete_folder(new_assets_dir / "__pycache__", force=True)

    print(f"[INFO] Updated UAV folder: {new_uav_dir}")
    print(f"[INFO] Updated assets folder: {new_assets_dir}")
    print(f"[INFO] UAV renamed successfully from '{old_name}' ‚Üí '{new_name}'")

# ---------------------------------------------------------------------
# UAV Delete Functionality
# ---------------------------------------------------------------------
def case_sensitive_path(parent, name):
        """Return the exact path if it exists with matching case."""
        for child in Path(parent).iterdir():
            if child.name == name:  # exact match (case-sensitive)
                return child
        return None
    
def delete_uav(base_dir, assets_dir, uav_name, force=False):
    """Deletes a UAV's code package and its assets (case-sensitive)."""

    uav_dir = case_sensitive_path(base_dir, uav_name)
    assets_dir_vehicles = Path(assets_dir) / "vehicles"
    assets_dir_path = case_sensitive_path(assets_dir_vehicles, uav_name)

    # Check existence
    if not uav_dir and not assets_dir_path:
        print(f"[WARNING] UAV '{uav_name}' does not exist (case-sensitive check).")
        return

    # Confirmation prompt (unless --force)
    if not force:
        confirm = input(
            f"[WARNING] Are you sure you want to permanently delete UAV '{uav_name}'? (y/N): "
        ).strip()
        if confirm.lower() not in {"y", "yes"}:
            print("[INFO] Deletion cancelled.")
            return

    # Delete UAV code folder
    if uav_dir:
        shutil.rmtree(uav_dir)
        print(f"[INFO] Deleted UAV package folder: {uav_dir}")

    # Delete assets folder
    if assets_dir_path:
        shutil.rmtree(assets_dir_path)
        print(f"[INFO] Deleted assets folder: {assets_dir_path}")

    print(f"[INFO] UAV '{uav_name}' deleted successfully.")

# ---------------------------------------------------------------------
# List UAVs Functionality
# ---------------------------------------------------------------------
def list_uavs(base_dir, assets_dir):
    base_dir = Path(base_dir)
    assets_dir = Path(assets_dir) / "vehicles"
    if not base_dir.exists():
        print("[WARNING] No UAV directory found.")
        return

    uav_dirs = [d for d in base_dir.iterdir() if d.is_dir() and not d.name.startswith("_")]
    if not uav_dirs:
        print("[WARNING] No UAVs found.")
        return

    print("[INFO] Available UAVs:\n" + "‚îÄ" * 40)
    for d in sorted(uav_dirs):
        name = d.name
        class_file = next(d.glob(f"{name}.py"), None)
        config_file = next(d.glob(f"{name}_config.yaml"), None)
        gains_dir = d / "Controller_Gains"
        if gains_dir.exists():
            if any(gains_dir.glob("*.yaml")):
                gains_check_str = '‚úÖ'
            else:
                gains_check_str = '‚ùå Missing gains yaml files' 
        else:
            gains_check_str = '‚ùå Missing Folder'
        assets_path = assets_dir / name
        if assets_path.exists():
            if not any(assets_path.glob("*.py")):
                assets_check_str = '‚ùå Missing pychrono export ".py" file' 
            elif not any(assets_path.glob("*shapes")):
                assets_check_str = '‚ö†Ô∏è  Missing shapes folder' 
            else:
                assets_check_str = '‚úÖ'
        else:
            assets_check_str = '‚ùå Missing Folder'
        print(f"üöÅ  {name}") # üõ†Ô∏èüõ©Ô∏èüõ∞Ô∏è‚úàÔ∏èüõ∞ñ£òüõ∏üëæ‚úàüõ¶·Øì‚úàÔ∏éüõ©íÖííàîíÖííá´íÑÜ‚úáüöÄüöÅ
        print(f"    ‚îú‚îÄ UAV Class: {'‚úÖ' if class_file else '‚ùå Missing'}")
        print(f"    ‚îú‚îÄ Config: {'‚úÖ' if config_file else '‚ùå Missing'}")
        print(f"    ‚îú‚îÄ Controller Gains: {gains_check_str}") 
        print(f"    ‚îî‚îÄ Assets (CAD): {assets_check_str}\n")
    print("‚îÄ" * 40)
    print(f"[INFO] {len(uav_dirs)} UAV(s) found.\n")
  
# ---------------------------------------------------------------------
# Command Line Interface (CLI)
# ---------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Manage UAV packages for acsl_pychrono (create, rename, delete, list).",
        formatter_class=argparse.RawTextHelpFormatter
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--uav_create", help="UAV name to create (e.g., X8, QUAD)")
    parser.add_argument("--template", choices=["X8", "QUAD"], default=DEFAULT_UAV, help=f'Template if config not provided, default="{DEFAULT_UAV}"')
    parser.add_argument("--uav_py", help="Path to UAV Python class file")
    parser.add_argument("--config", help="Path to UAV YAML config file")
    parser.add_argument("--gains_folder", help="Path to folder with predefined controller gain YAML files")
    parser.add_argument("--uav_chrono_py", help="Path to PyChrono/SolidWorks export file (.py)")
    parser.add_argument("--shapes", help="Path to .obj shape folder")
    
    group.add_argument("--uav_rename", nargs=2, metavar=("OLD_NAME", "NEW_NAME"), help="Rename an existing UAV")
    
    group.add_argument("--uav_delete", help="Delete a UAV (all folder structures)")
    parser.add_argument("--force", action="store_true", help="Skip confirmation prompts (for delete)")
    
    group.add_argument("--list_uavs", action="store_true", help="List all available UAVs")
    
    parser.add_argument("--base_dir", default="acsl_pychrono/uav", help="Base directory for UAV code packages, default='acsl_pychrono/uav/'")
    parser.add_argument("--assets_dir", default="assets", help="Base directory for assets (where /vehicles/ is located), default='assets/'")

    args = parser.parse_args()

    if args.uav_rename:
        rename_uav(args.base_dir, args.assets_dir, args.uav_rename[0], args.uav_rename[1])
    elif args.uav_delete:
        delete_uav(args.base_dir, args.assets_dir, args.uav_delete, args.force)
    elif args.list_uavs:
        list_uavs(args.base_dir, args.assets_dir)
    else:
        create_uav_structure(
            base_dir=args.base_dir,
            assets_dir=args.assets_dir,
            uav_name=args.uav_create,
            config_path=args.config,
            shapes_path=args.shapes,
            uav_py_path=args.uav_py,
            uav_chrono_py_path=args.uav_chrono_py,
            gains_folder=args.gains_folder,
            template=args.template,
        )