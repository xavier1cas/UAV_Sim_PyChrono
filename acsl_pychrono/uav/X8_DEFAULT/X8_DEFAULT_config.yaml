uav:
  number_of_propellers: 8

  cad:
    pychono_export: "x8copter.py" # Must match the name of the .py file exported from pychrono in the assets/vehicles folder
    ground: "ground"
    frame: "drone_big_box"
    box: "box_big_200x200x100"
    prop_prefix: "3_blade_prop"

  pixhawk:
    position_local : [0.0293, 0.04925, 0]                 # for chrono vector 
    orientation_ned: [0.70710678118, 0.70710678118, 0, 0] # for chrono quaternion (NED - North East Down)
    orientation_yup: [1, 0, 0, 0]                         # for chrono quaternion (YUP - Y up)

  mass_total: 2.025 # [kg] 2.025 -- 3.1, Get the estimate from Solidworks

  inertia: # Get it from the center of mass of the full assembly
  # (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
    Lxx : 0.0227199027
    Lyy : 0.0161469360
    Lzz : 0.0220204718
    Lxy : 0.0010034978
    Lxz : -0.0000065570
    Lyz : -0.0000056584

  aerodynamics:
    surface_area: 0.07      # Surface area of the drone to account for drag [m^2]
    drag_coefficient: 1.28  # Drag coefficient (equal to that of a plate) [-]

  # FOR NOW, USE HIGH VALUES OF MAX AND MIN THRUST TO AVOID SATURATION (max_thrust = 100N)
  # TO BE UPDATED WITH ACTUAL MOTOR-PROPELLER COMBINATION
  motor:
    # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
    # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
    # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
    # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
    # maximum_motor_thrust: 21.25 # [N] Maximum thrust that can be produced by a motors'couple
    max_thrust: 10.625    # [N] per motor, Maximum thrust that can be produced by a SINGLE motor = 10.625 N
    # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
    # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
    # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
    # minimum_motor_thrust: 1.255 # [N] Minimum thrust that can be produced by a motors'couple
    min_thrust: 0.6275    # [N] per motor, Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
    # Motor efficiency coefficients for simulating motor failure
    efficiency_matrix_diag: [1,1,1,1,1,1,1,1]
    efficiency_matrix_diag_after_failure: [0,1,1,1,1,1,1,1]
    
    # Reorder or define coaxial stacking (OPTIONAL)
    index_map: [2, 3, 0, 1, 6, 7, 4, 5]
    # Motors' rotation direction
    # Motor 1: CCW
    # Motor 2: CW
    # Motor 3: CCW
    # Motor 4: CW
    # Motor 5: CW
    # Motor 6: CCW       
    # Motor 7: CW
    # Motor 8: CCW
    # Define spin direction of each motor: +1 for CCW, -1 for CW
    spin_directions: [1, -1, 1, -1, -1, 1, -1, 1]

  mixer_matrix:
  # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x: 0.0881269  # distance between centerline of the drone and the motors along x direction in Local NED convention
    l_y: 0.1083450  # distance between centerline of the drone and the motors along y direction in Local NED convention
    c_t: 0.01       # drag coefficient of propellers
    # U_matrix_inverse: [[],[],[]]# if existing pseudo-inverse

  force_positions:
  # position wrt local frame of where to apply the thrust force generated by motors 1 & 5, 2 & 6 , 3 & 7, 4 & 8
    - [-0.08760601358, -0.0085, -0.10859150436] # 1 & 5
    - [ 0.08812691616, -0.0085, -0.10834502049] # 2 & 6
    - [ 0.08760601358, -0.0085,  0.10859150436] # 3 & 7
    - [-0.08812691616, -0.0085,  0.10834502049] # 4 & 8

  # point where to apply the aerodynamic force in local frame (try with the center of mass of the drone)
  aerodynamic_force_application_point: [-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05]

controller:
  # These shouldn't change unless you change the mission
  derivative_filter_gains:
    # Roll filters gains (from matlab)
    A_phi_ref: [[-15, -225],[1, 0]]
    B_phi_ref: [[1],[0]]
    C_phi_ref: [225, 0]
    D_phi_ref: 0
    # Pitch filters gains (from matlab)
    A_theta_ref: [[-15, -225],[1, 0]]
    B_theta_ref: [[1],[0]]
    C_theta_ref: [225, 0]
    D_theta_ref: 0
  K_omega: 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. controller.motor_thrusts = K * omega^2
  K_torque: !!float 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2

  gain_yaml_files:  
    PID: "PID.yaml"
    MRAC: "MRAC.yaml"
    TwoLayerMRAC: "TwoLayerMRAC.yaml"