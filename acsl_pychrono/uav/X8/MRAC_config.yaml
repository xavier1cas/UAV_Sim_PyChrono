parameters:
  # Number of states to be integrated by RK4
  number_of_states: 106
  # Length of the array vector that will be exported 
  size_DATA: 181

  # ----------------------------------------------------------------
  #                     Baseline Parameters
  # ----------------------------------------------------------------

  # **Translational** baseline parameters to let the reference model follow the user-defined model (mu_baseline_tran)
  KP_tran: [5,5,6]
  KD_tran: [8,8,3]
  KI_tran: [1,1,0.1]

  # **Translational** parameters for the PD baseline controller (mu_PD_baseline_tran)
  KP_tran_PD_baseline: [5,5,6]
  KD_tran_PD_baseline: [8,8,3]

  # **Rotational** baseline parameters
  KP_rot: np.matrix(3e0 * np.diag([10,10,5]))
  KI_rot: np.matrix(2e0 * np.diag([1,1,1]))

  # **Rotational** parameters for the PI baseline controller (Moment_baseline_PI)       
  KP_rot_PI_baseline: np.matrix(4.5e1 * np.diag([1,1,0.5]))
  KI_rot_PI_baseline: np.matrix(5.5e1 * np.diag([1,1,0.5]))

  K_P_omega_ref: np.matrix(3.8e1 * np.diag([0.8,0.8,1.2]))
  K_I_omega_ref: np.matrix(1e-1 * np.diag([5,5,1]))

  # ----------------------------------------------------------------
  #                   Translational Parameters MRAC
  # ----------------------------------------------------------------

  # Plant parameters **Translational** dynamics
  A_tran: np.block([[np.zeros((3, 3)),   np.identity(3)],
                      [np.zeros((3, 3)), np.zeros((3, 3))]])

  B_tran: np.matrix(np.block([[np.zeros((3, 3))],
                                    [np.identity(3)]]))

  # **Translational** reference model parameters and estimates
  A_ref_tran: np.block([[np.zeros((3, 3)),  np.identity(3)], [        -KP_tran       -KD_tran)

  B_ref_tran: np.matrix(np.block([[np.zeros((3, 3))],  [(1/mass_total_estimated:np.identity(3)]]))

  # **Translational** adaptive parameters
  Gamma_x_tran: np.matrix(1e1 * np.diag([1,1,10,1,1,10])) # Adaptive rates
  Gamma_r_tran: np.matrix(3e-2 * np.diag([1,1,4])) # Adaptive rates
  Gamma_Theta_tran: np.matrix(1e1 * np.diag([1,1,2,1,1,2])) # Adaptive rates

  # **Translational** parameters Lyapunov equation
  Q_tran: np.matrix(6e-2 * np.diag([1,1,12,1,1,2]))
  P_tran: np.matrix(linalg.solve_continuous_lyapunov(A_ref_tran, -Q_tran)

  # ----------------------------------------------------------------
  #                   Rotational Parameters MRAC
  # ----------------------------------------------------------------

  # Plant parameters **Rotational** dynamics
  A_rot: np.matrix(np.zeros((3,3)))
  B_rot: np.matrix(np.eye(3))

  # **Rotational** reference model parameters
  A_ref_rot: -K_P_omega_ref   B_ref_rot np.matrix(np.eye(3))

  # **Rotational** parameters Lyapunov equation
  Q_rot: np.matrix(1e-3 * np.diag([0.3333, 0.4, 0.6]))
  P_rot: np.matrix(linalg.solve_continuous_lyapunov(A_ref_rot:, -Q_rot

  # **Rotational** adaptive parameters
  Gamma_x_rot: np.matrix(1e4 * np.diag([1,1,1])) # Adaptive rates
  Gamma_r_rot: np.matrix(5e0 * np.diag([1,1,1])) # Adaptive rates
  Gamma_Theta_rot: np.matrix(2e3 * np.diag([1,1,1,1,1,1])) # Adaptive rates
  
  # ----------------------------------------------------------------
  #                   Safety Mechanism Parameters
  # ----------------------------------------------------------------
  use_safety_mechanism: True
  
  # Mu - sphere intersection
  sphereEpsilon: 1e-2
  maximumThrust: 85 # [N] 85
  
  # Mu - elliptic cone intersection
  EllipticConeEpsilon: 1e-2
  maximumRollAngle: math.radians(60) # [rad] 25 - 32
  maximumPitchAngle: math.radians(60) # [rad] 25 - 32
  
  # Mu - plane intersection
  planeEpsilon: 1e-2
  alphaPlane: 0.6 # [-] coefficient for setting the 'height' of the bottom plane. Must be >0 and <1.

  # ----------------------------------------------------------------
  #                  Dead-Zone modification Parameters
  # ----------------------------------------------------------------
  use_dead_zone_modification: True

  dead_zone_delta_tran: 0.5
  dead_zone_e0_tran: 0.01

  dead_zone_delta_rot: 0.5
  dead_zone_e0_rot: 0.002

  # ----------------------------------------------------------------
  #                  e-modification Parameters
  # ----------------------------------------------------------------
  use_e_modification: True

  sigma_x_tran: 0.5
  sigma_r_tran: 0.5
  sigma_Theta_tran: 0.5

  sigma_x_rot: 0.5
  sigma_r_rot: 0.5
  sigma_Theta_rot: 0.5

  # ----------------------------------------------------------------
  #                  Projection Operator Parameters
  # ----------------------------------------------------------------
  use_projection_operator: True

  # K_x_hat translational
  x_e_x_tran: np.zeros((18, 1))
  S_diagonal_x_tran: 30 * np.ones((18, 1))
  alpha_x_tran: 0.1

  # K_r_hat translational
  x_e_r_tran: np.zeros((9, 1))
  S_diagonal_r_tran: 2.5 * np.ones((9, 1))
  alpha_r_tran: 0.1

  # Theta_hat translational
  x_e_Theta_tran: np.zeros((18, 1))
  S_diagonal_Theta_tran: 7.5 * np.ones((18, 1))
  alpha_Theta_tran: 0.1

  # K_x_hat rotational
  x_e_x_rot: np.zeros((9, 1))
  S_diagonal_x_rot: 5.0 * np.ones((9, 1))
  alpha_x_rot: 0.1

  # K_r_hat rotational
  x_e_r_rot: np.zeros((9, 1))
  S_diagonal_r_rot: 0.1 * np.ones((9, 1))
  alpha_r_rot: 0.1

  # Theta_hat rotational
  x_e_Theta_rot: np.zeros((18, 1))
  S_diagonal_Theta_rot: 10 * np.ones((18, 1))
  alpha_Theta_rot: 0.1