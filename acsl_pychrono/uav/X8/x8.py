import numpy as np
import pychrono as chrono
import acsl_pychrono.uav as UAV_module
from acsl_pychrono.uav.uav import UAV

# X-8 Copter Motors enumeration and Global reference frame (Reference frame acquired by SolidWorks)
#
# 2                  3
# -                  -
# 6 \    forward   / 7
#    \      ^ X   /
#     \     |    /
#      \____|___/
#      |    |   |
#      |    |   |
#      |    |   |
#      |   O|___|______> Z right
#      |   Y up |
#      |        |
#      |________|
#      /        \
#     /          \
#    /            \
# 1 /              \ 4
# -                  -
# 5                  8
#

class X8 (UAV) :
  def __init__(self):
    super().__init__()
    
    # UAV specific parameters
    cfg = UAV_module.get_uav_config("X8") # Config Dictionary
    
    self.number_of_propellers = cfg["uav"]["number_of_propellers"]
    
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
    Lxx = cfg["uav"]["inertia"]["Lxx"]
    Lyy = cfg["uav"]["inertia"]["Lyy"]
    Lzz = cfg["uav"]["inertia"]["Lzz"]
    Lxy = cfg["uav"]["inertia"]["Lxy"]
    Lxz = cfg["uav"]["inertia"]["Lxz"]
    Lyz = cfg["uav"]["inertia"]["Lyz"]
    matrix_solidworks = np.array([[Lxx, Lxy, Lxz],
                                  [Lxy, Lyy, Lyz],
                                  [Lxz, Lyz, Lzz]])
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
    self.Inertia_mat_pixhawk = np.matmul(
      self.RotMat_X_PI_2_array, np.matmul(
        matrix_solidworks,
        self.RotMat_X_PI_2_tran_array)
      )

    self.surface_area = cfg["uav"]["aerodynamics"]["surface_area"]
    self.drag_coefficient = cfg["uav"]["aerodynamics"]["drag_coefficient"]

    # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x = cfg["uav"]["mixer_matrix"]["l_x"] 
    l_y = cfg["uav"]["mixer_matrix"]["l_y"]
    c_t = cfg["uav"]["mixer_matrix"]["c_t"]

    # Mixer matrix for QUADcopter 
    # U_mat = np.array([[ 1,    1,    1,    1  ], 
    #                   [ l_y,  l_y, -l_y, -l_y],
    #                   [-l_x,  l_x,  l_x, -l_x],
    #                   [-c_t,  c_t, -c_t,  c_t]])

    # Mixer matrix for X8copter configuration
    # [   1,   1,    1,    1,    1,    1,    1,    1]
    # [ l_y, l_y, -l_y, -l_y,  l_y,  l_y, -l_y, -l_y]
    # [-l_x, l_x,  l_x, -l_x, -l_x,  l_x,  l_x, -l_x]
    # [-c_t, c_t, -c_t,  c_t,  c_t, -c_t,  c_t, -c_t]

    # Moore-Penrose pseudo-inverse of X8copter mixer matrix
    self.U_mat_inv = (1/8)*np.array([
      [1,  1/l_y, -1/l_x, -1/c_t],
      [1,  1/l_y,  1/l_x,  1/c_t],
      [1, -1/l_y,  1/l_x, -1/c_t],
      [1, -1/l_y, -1/l_x,  1/c_t],
      [1,  1/l_y, -1/l_x,  1/c_t],
      [1,  1/l_y,  1/l_x, -1/c_t],
      [1, -1/l_y,  1/l_x,  1/c_t],
      [1, -1/l_y, -1/l_x, -1/c_t]
    ])

    
    self.maximum_motor_thrust = cfg["uav"]["motor"]["max_thrust"] # Maximum thrust [N] per motor
    self.minimum_motor_thrust = cfg["uav"]["motor"]["min_thrust"] # Minimum thrust [N] per motor
    self.motor_efficiency_matrix = np.matrix(np.diag(cfg["uav"]["motor"]["efficiency_matrix_diag"])) # Motor efficiency coefficients
    self.motor_efficiency_matrix_after_failure = np.matrix(np.diag(cfg["uav"]["motor"]["efficiency_matrix_diag_after_failure"])) # Motor efficiency coefficients after failure
    self.motor_index_map = cfg["uav"]["motor"]["index_map"] # Reorder or define coaxial stacking (OPTIONAL)
    self.propellers_spin_directions = cfg["uav"]["motor"]["spin_directions"] # Motors' spin direction
    
    # Force positions
    self.motor_force_positions = tuple(
      chrono.ChVectorD(*pos) for pos in cfg["uav"]["force_positions"]
    )
    
    # point where to apply the aerodynamic force in local frame
    self.aerodynamic_force_application_point = chrono.ChVectorD(*cfg["uav"]["aerodynamic_force_application_point"])