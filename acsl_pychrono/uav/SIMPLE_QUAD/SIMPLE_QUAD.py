import numpy as np
from pathlib import Path
import acsl_pychrono.uav as UAV_module
from acsl_pychrono.uav.uav_parent_class_file import UAV_PARENT_CLASS as UAV

# ThrustStand UAV Motors enumeration and Global reference frame (Reference frame acquired by SolidWorks)
#
#               
#  1 - CW           2 - CCW
#   \    forward   /
#    \      ^ X   /
#     \     |    /
#      \____|___/
#      |    |   |
#      |    |   |
#      |    |   |
#      |   O|___|______> Z right
#      |   Y up |
#      |        |
#      |________|
#      /        \
#     /          \
#    /            \
#   /              \
#  4 - CCW          3 - CW
#

class UAV_INSTANCE (UAV) :
  def __init__(self):
    super().__init__()
    
    # Get the UAV name from the class name
    self.name = Path(__file__).stem
    
    # UAV specific parameters
    cfg = UAV_module.get_uav_config(self.name) # Config Dictionary
    
    self.loadFromYAML(cfg)  # Load generic parameters
    
    # --- UAV-specific ---
    self._load_inertia()
    self._compute_mixer_matrix(cfg)
    
  def _load_inertia(self):
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
    # Since the inertia_matrix_untransformed was obtained in the Solidworks coordinate sys (yup), it needs to be transformed to (ned)
    self.Inertia_mat_pixhawk = self.RotMat_X_PI_2_array @ self.inertia_matrix_untransformed @ self.RotMat_X_PI_2_tran_array    

  def _compute_mixer_matrix(self, cfg):
    # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x = float(cfg["uav"]["mixer_matrix"]["l_x"]) 
    l_y = float(cfg["uav"]["mixer_matrix"]["l_y"])
    c_t = float(cfg["uav"]["mixer_matrix"]["c_t"])

    # Mixer matrix for QUADcopter 
    # U_mat = np.array([[   1,   1,    1,    1,], 
    #                   [ l_y, l_y, -l_y, -l_y,],
    #                   [-l_x, l_x,  l_x, -l_x,],
    #                   [-c_t, c_t, -c_t,  c_t,]])

    # Moore-Penrose pseudo-inverse of X8copter mixer matrix
    self.U_mat_inv = np.array([
      [1/4,  1/(4*l_y),  1/(4*l_x),  1/(4*c_t)],
      [1/4, -1/(4*l_y),  1/(4*l_x), -1/(4*c_t)],
      [1/4, -1/(4*l_y), -1/(4*l_x),  1/(4*c_t)],
      [1/4,  1/(4*l_y), -1/(4*l_x), -1/(4*c_t)]
    ])