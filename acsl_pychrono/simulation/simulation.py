import time
import sys
from pathlib import Path 
import numpy as np
from numpy import linalg as LA

import pychrono as chrono
import pychrono.irrlicht as irr

import acsl_pychrono.simulation.functions as fun
from acsl_pychrono.simulation.visualization import Visualization
from acsl_pychrono.simulation.pixhawk_state import PixhawkState, VehicleState
from acsl_pychrono.simulation.flight_params import FlightParams
from acsl_pychrono.simulation.ode_input import OdeInput
import acsl_pychrono.config.config as Cfg
import acsl_pychrono.user_defined_trajectory as Traj
from acsl_pychrono.simulation.utils import Utils
from acsl_pychrono.control.control import Control
import acsl_pychrono.uav as UAV_Module

class Simulation:
  def __init__(self, sim_cfg: Cfg.SimulationConfig = Cfg.SimulationConfig()) -> None:
    # Chrono settings
    self.m_sys = chrono.ChSystemNSC()
    self.vis: irr.ChVisualSystemIrrlicht | None = None
    self.visualization = Visualization(self)
    
    # Chrono features
    self.m_ground = None
    self.m_frame: chrono.ChBody = chrono.ChBody()
    self.m_box: chrono.ChBody = chrono.ChBody()
    self.m_props: list[chrono.ChBody] = []
    self.m_markers = []
    self.m_motors = []

    # Vehicle state
    self.vehicle_state: VehicleState = VehicleState()
    self.pixhawk_state: PixhawkState = PixhawkState()

    # Config members
    self.simulation_config: Cfg.SimulationConfig = sim_cfg
    self.mission_config: Cfg.MissionConfig = sim_cfg.mission_config
    self.vehicle_config: Cfg.VehicleConfig = sim_cfg.vehicle_config
    self.environment_config: Cfg.EnvironmentConfig = sim_cfg.environment_config
    self.wrapper_params: Cfg.WrapperParams = sim_cfg.wrapper_params
    
    # UAV specific parameters
    self.setUpUAVParams()

    # Additional initialization
    self.setUpSimulation()

  def setUpSimulation(self):
    """
    Function to include in __init__() that sets additional simulation settings and performs the setup of the simulation
    """
    self.loadVehicleModel()
    self.loadEnvironmentModel()
    self.setSolverAndCollisionModel()
    self.loadBodies()
    self.loadMarkers()
    self.createAuxillaryCoordinateSystems()
    self.createFloor()
    self.addPayload()
    self.addMotors()
    self.m_frame.Accumulate_force(chrono.ChVectorD(0, 0, 0), chrono.VNULL, True)
    
  def setUpUAVParams(self):
    """
    Sets UAV-specific parameters needed for simulation setup
    before specific UAV gets instantiated
    based on the selected UAV type from the configuration.
    """
    self.uav_name = self.vehicle_config.uav_name
    uav_cfg = UAV_Module.get_uav_config(self.uav_name) # Config Dictionary
    
    self.number_of_propellers = uav_cfg["uav"]["number_of_propellers"]
    
    self.pychono_export      = uav_cfg["uav"]["cad"]["pychono_export"]
    self.cad_ground          = uav_cfg["uav"]["cad"]["ground"]
    self.cad_frame           = uav_cfg["uav"]["cad"]["frame"]
    self.cad_prop_prefix     = uav_cfg["uav"]["cad"]["prop_prefix"]
    self.cad_box             = uav_cfg["uav"]["cad"]["box"]
    
    self.pixhawk_local_pos = uav_cfg["uav"]["pixhawk"]["position_local"]
    self.pixhawk_q_ned     = uav_cfg["uav"]["pixhawk"]["orientation_ned"]
    self.pixhawk_q_yup     = uav_cfg["uav"]["pixhawk"]["orientation_yup"]

  def setGravitationalAcceleration(self, flight_params: FlightParams):
    self.m_sys.Set_G_acc(chrono.ChVectorD(0,-flight_params.uav.G_acc,0))
  
  def loadVehicleModel(self):
    """
    Assigning names to the bodies imported from solidworks and checking if they are found
    """
    # Get the absolute path to the CAD model imported from SolidWorks to PyChrono
    # Prepend working directory and "/assets/vehicles"
    base_path = Path.cwd() / "assets/vehicles"
    full_path = base_path / self.uav_name / self.pychono_export #f"{self.uav_name}_export.py"
    # Remove .py extension from the name
    chrono_cad_module_path = full_path.with_suffix('')
    
    # Load the file generated by the SolidWorks CAD plugin and add it to the ChSystem.
    self.exported_items = chrono.ImportSolidWorksSystem(chrono_cad_module_path)

    # Add items to the physical system
    for my_item in self.exported_items:
      self.m_sys.Add(my_item)
      

  # TODO: Generalize for different CAD models and number of propellers (DONE!)
  def loadBodies(self):
    # Ground (required)
    m_ground = self.m_sys.SearchBody(self.cad_ground)
    if not m_ground:
      sys.exit('[ERROR] Cannot find ground from its name in the C::E system!')
    
    # Frame (required)
    self.m_frame = self.m_sys.SearchBody(self.cad_frame + '-1')
    if not self.m_frame:
      sys.exit('[ERROR] Cannot find drone frame from its name in the C::E system!')
    
    # Box (optional)
    if self.cad_box != "":
      self.m_box = self.m_sys.SearchBody(self.cad_box + '-1')
      if not self.m_box:
        print(f'[WARNING] Cannot find box "{self.cad_box}-1" — skipping box.')
    else:
      print('[WARNING] No box CAD model specified, skipping box.')
    
    # Propellers (optional)
    self.m_props = []
    if self.cad_prop_prefix != "":
      for i in range(1, self.number_of_propellers + 1):
        name = f"{self.cad_prop_prefix}-{i}"
        prop = self.m_sys.SearchBody(name)
        if not prop:
          print(f'[WARNING] Cannot find propeller "{name}" — skipping.')
          continue
        self.m_props.append(prop)
    else:
      print('[WARNING] No propeller CAD prefix specified, skipping props.')
      
    print('[INFO] Body loading completed.')

  def loadMarkers(self):
    """
    Assigning names to the Coordinate Systems/Markers imported from solidworks and checking if they are found
    """
    self.m_markers = []
    for i in range(1, self.number_of_propellers + 1):
      name = f'Coordinate System{i}'
      marker = self.m_sys.SearchMarker(name)
      if not marker:
        sys.exit(f'[ERROR] Cannot find marker{i} from its name in the C::E system!')
      self.m_markers.append(marker)

  # TODO: Generalize for arbitrary # of propellers (DONE!)
  def addMotors(self):
    """
    Create the UAV motors.
    If propeller CAD models exist, attach the motors to them.
    Otherwise, create force-based virtual motors at the correct marker locations.
    """
    # Check required components
    if not (self.m_frame and self.m_markers):
      sys.exit("[ERROR] Frame and markers must be loaded before adding motors!")

    self.m_motors = []

    # If we have real propeller CAD models
    if self.m_props != []:
      self.m_motors = []
          
      for i in range(self.number_of_propellers):
        frame = self.m_markers[i].GetAbsFrame()
        motor = chrono.ChLinkMotorRotationSpeed()
        motor.Initialize(self.m_props[i], self.m_frame, frame)
        motor.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
        # motor.SetMotorFunction(chrono.ChFunction_Const(5.0 * chrono.CH_C_2PI))  # Uncomment if needed
        self.m_sys.Add(motor)
        self.m_motors.append(motor)

    # Otherwise, skip CAD model
    else:
      print("[INFO] No propeller CAD models found — skipping propeller simulation.")

    print(f"[INFO] Added {len(self.m_motors)} motors to the UAV.")
    
  def getBodies(self):
    return (
      self.m_frame,
      self.m_box,
      *self.m_props
    )

  def getMarkers(self):
    return tuple(self.m_markers)
  
  def getMotors(self):
    return tuple(self.m_motors)

  def loadEnvironmentModel(self):
    if not self.environment_config.include:
      print("[INFO] Environment model loading skipped (config.environment.include=False).")
      return
    
    # Prepend working directory and "/assets/environments"
    base_path = Path.cwd() / "assets/environments"
    full_path = base_path / self.environment_config.model_relative_path
    # Remove .py extension from the name
    modulename = full_path.with_suffix('')

    # Import the environment model
    self.exported_items_env = chrono.ImportSolidWorksSystem(modulename)

    # Add all items to the physical system
    for item in self.exported_items_env:
      print(item.GetName())
      self.m_sys.Add(item)

    # Filter out 'ground' and only keep bodies
    bodies = [
      item for item in self.exported_items_env
      if isinstance(item, chrono.ChBody) and item.GetName() != "ground"
    ]

    if len(bodies) != 1:
      sys.exit(f"Error: Expected exactly 1 non-ground body in the environment model, found {len(bodies)}.")

    self.m_environment = bodies[0]
    print(f"[INFO] Environment body loaded: {self.m_environment.GetName()}")

  def setSolverAndCollisionModel(self):
    # self.m_solver = chrono.ChSolverBB() # default solver set by the solidworks pychrono module
    self.m_solver = chrono.ChSolverPSOR() # same solver as 'demo_MBS_collisionNSC'
    self.m_sys.SetSolver(self.m_solver)
    self.m_solver.SetMaxIterations(1000) #600 #1000
    self.m_solver.EnableWarmStart(True)
    chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.001) #0.003 #0.001
    chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.0005) #0.003 #0.0005
    chrono.ChCollisionSystemBullet.SetContactBreakingThreshold(0.001) #0.002 #0.001

  # TODO: Needs to be generalized for any UAV (DONE!)
  def createAuxillaryCoordinateSystems(self):
    """
    Creates auxiliary coordinate systems (Pixhawk, global, frame, box) for the UAV.
    """
    # 1) Extract configuration
    pos_pixhawk = chrono.ChVectorD(*self.pixhawk_local_pos)
    q_ned = chrono.ChQuaternionD(*self.pixhawk_q_ned)
    q_yup = chrono.ChQuaternionD(*self.pixhawk_q_yup)
    # # position of the "pixhawk's center" wrt the COG of the drone frame
    # position_pixhawk_fromCOG = chrono.ChVectorD(-0.0214807964657055, 0.0779592340719906, -0.0000487571767365452) 
    
    # 2) Define global reference frame
    self.global_coord = chrono.ChCoordsysD(
        chrono.ChVectorD(0, 0, 0), 
        chrono.ChQuaternionD(1, 0, 0, 0)
    )

    # 3) Define Pixhawk coordinate systems
    self.pixhawk_csys = chrono.ChCoordsysD(pos_pixhawk, q_ned) # Coordinate System Pixhawk (NED - North East Down)
    pixhawk_csys_yup = chrono.ChCoordsysD(pos_pixhawk, q_yup)  # Coordinate System Pixhawk with (YUP - Y up)

    # 4) Add markers to frame (reusable across UAVs)
    self.marker_pixhawk = chrono.ChMarker()
    self.marker_pixhawk.SetName("Coordinate System Pixhawk (NED)") # Create a local reference system with NED convention
    self.m_frame.AddMarker(self.marker_pixhawk)
    self.marker_pixhawk.Impose_Abs_Coord(self.pixhawk_csys)

    self.marker_pixhawk_2 = chrono.ChMarker()
    self.marker_pixhawk_2.SetName("Coordinate System Pixhawk (Y-up)")  # Create a local reference system with Y up convention
    self.m_frame.AddMarker(self.marker_pixhawk_2)
    self.marker_pixhawk_2.Impose_Abs_Coord(pixhawk_csys_yup)

    # 5) Rotation matrix for 90° (pi/2) rotation about X-axis (Used to convert y-up to NED reference frames)
    self.RR = chrono.ChMatrix33D()
    RRX_plusPI2 = [[1,  0, 0],
                   [0,  0, 1],
                   [0, -1, 0]]
    self.RR.SetMatr(RRX_plusPI2)

    # 6) Store reference coordinate systems for box and frame
    self.m_frame_csys = self.m_frame.GetFrame_REF_to_abs().GetCoord() # Identify Local reference system of drone frame
    self.m_box_csys = self.m_box.GetFrame_REF_to_abs().GetCoord() # Identify Local reference system of Box

  def createFloor(self):
    contact_material_floor = chrono.ChMaterialSurfaceNSC()
    contact_material_floor.SetFriction(1) # 1
    contact_material_floor.SetDampingF(0.5) # 0.5
    self.mfloor = chrono.ChBodyEasyBox(50, 0.1, 50, 1000,True,True, contact_material_floor)
    self.mfloor.SetName('Floor')
    self.mfloor.SetBodyFixed(True)
    self.mfloor_Yposition = 0.3
    self.mfloor.SetPos(chrono.ChVectorD(0,-self.mfloor_Yposition,0))
    self.mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/light_gray.png"))
    self.m_sys.Add(self.mfloor)

  def addTwoSteelBallsPayload(self):
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      ball_radius = 0.0254 # 0.0254 - 0.01905 - 0.015875
      # my_ball_density = 7850
      my_ball_density = getattr(self.wrapper_params, "my_ball_density", 7850)
      self.m_ball1 = chrono.ChBodyEasySphere(
        ball_radius,      # radius size 
        my_ball_density,     # density
        True,     # visualization?
        True,     # collision?
        contact_material_ball # contact material
      )  
      self.m_ball1.SetName('Ball_1')
      self.m_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0.065)) # -0.05,-0.15,0
      self.m_ball1.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
      self.m_sys.Add(self.m_ball1)
      
      self.m_ball2 = chrono.ChBodyEasySphere(
        ball_radius,      # radius size
        my_ball_density,     # density
        True,     # visualization?
        True,     # collision?
        contact_material_ball # contact material
      )  
      self.m_ball2.SetName('Ball_2')
      self.m_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0.065))
      self.m_ball2.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker2.png"))
      self.m_sys.Add(self.m_ball2)

      # Identify Local reference system of Ball_1
      self.my_ball1_csys = self.m_ball1.GetFrame_REF_to_abs().GetCoord()
      # Identify Local reference system of Ball_2
      self.my_ball2_csys = self.m_ball2.GetFrame_REF_to_abs().GetCoord()

      self.setupCOMcomputationOfSystemWithPayload()

  # TODO: Generalize for arbitrary # of propellers (DONE!)
  # TODO: Generalize for different propeller masses (DONE!)
  def setupCOMcomputationOfSystemWithPayload(self):
    """
    Setup mass properties and prepare COM computation for the UAV + payload.
    Generalized for arbitrary number of propellers and optional per-prop masses.
    """
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):
      # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
      # 1) Get core masses
      self.m_frame_mass = self.m_frame.GetMass()
      if self.cad_box != "":
        self.m_box_mass = self.m_box.GetMass()
      else:
        self.m_box_mass = 0.0
        print("[INFO] Box mass set to zero.")
      print(f"[DEBUG] Box mass = {self.m_box_mass} [kg]")
      
      # 2) Compute propeller masses dynamically
      self.m_prop_masses = []
      for prop in self.m_props:
        m_prop_mass = prop.GetMass()
        self.m_prop_masses.append(m_prop_mass)
      print(f"[DEBUG] Propeller masses = {self.m_prop_masses} [kg]")
      
      m_prop_total_mass = sum(self.m_prop_masses)
      
      # 3) Get payload masses
      self.m_ball1_mass = self.m_ball1.GetMass()
      self.m_ball2_mass = self.m_ball2.GetMass()
      
      # 4) Compute total system masses
      self.mass_total = self.m_frame_mass + self.m_box_mass + m_prop_total_mass
      self.mass_total_wballs = self.mass_total + self.m_ball1_mass + self.m_ball2_mass

      # 5) Initialize COG vectors (set to zero)
      self.COG_total = chrono.ChVectorD()
      self.COG = chrono.ChVectorD()

  # TODO: Generalize for any number of proppellers (DONE!)
  # TODO: Generalize for different propeller masses (DONE!)
  def updateCOMcomputationOfSystemWithPayload(self):
    """
    Compute Center Of Mass (COM) of the system: drone frame + box + propellers (+ payload).
    Generalized to support any number of propellers in self.m_props.
    """
    if self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls":
      # 1) Compute the position (in global coordinates) of the bodies
      # Global coordinates of the origin of the drone frame containing just the position
      my_frame_pos_GLOB = self.m_frame.GetPos()
      # This gives the position of the auxillary csys imported from/defined in SolidWorks
      # my_box_ref = my_box.GetFrame_REF_to_abs().GetCoord().pos 
      # Same as asking for .GetPos() --> meaning GetPos() refers to the COG position!!!!
      my_box_pos = self.m_box.GetFrame_COG_to_abs().GetCoord().pos

      # 2) Compute total propeller contribution dynamically
      # Check if we have a list of per-propeller masses
      # For this block to work, the generalization in setupCOMcomputationOfSystemWithPayload() must be done first
      total_prop_mass_contribution = chrono.ChVectorD(0, 0, 0)
      for prop, mass in zip(self.m_props, self.m_prop_masses):
        total_prop_mass_contribution += prop.GetPos() * mass

      # 3) Compute COG in Global Coordinates (with payload)
      # (First you must put the ChVector (position) and then you can multiply it by a float (mass). Order is important!!!)
      self.COG_total = (
        my_frame_pos_GLOB * self.m_frame_mass
        + my_box_pos * self.m_box_mass
        + total_prop_mass_contribution
        + self.m_ball1.GetPos() * self.m_ball1_mass
        + self.m_ball2.GetPos() * self.m_ball2_mass
      ) * (1 / self.mass_total_wballs)

      # 4) Compute COG without payload (drone only)
      self.COG = (
          my_frame_pos_GLOB * self.m_frame_mass
          + my_box_pos * self.m_box_mass
          + total_prop_mass_contribution
      ) * (1 / self.mass_total)

      # 5) Transform to local reference frame
      # Position of COG seen from the local reference system of the frame
      self.my_COG_local = self.m_frame_csys.TransformParentToLocal(self.COG)

      # 6) Transform payload and COG_total into box frame coordinates
      # Position of Ball1, Ball2 and COG_total seen from the local reference system of the Box
      self.my_ball1_pos_box = self.m_box_csys.TransformParentToLocal(self.m_ball1.GetPos())
      self.my_ball2_pos_box = self.m_box_csys.TransformParentToLocal(self.m_ball2.GetPos())
      self.COG_total_box = self.m_box_csys.TransformParentToLocal(self.COG_total)

  def addSpheresInArrays(self):
    if (self.mission_config.add_payload_flag
      and self.mission_config.payload_type == "ten_steel_balls_in_two_lines"
      ):
      self.m_spheres: list[chrono.ChBody] = []  # Store sphere bodies
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      radius = 0.015875
      density = 7850
      sphere_number = 10
      for i in range(sphere_number):
        sphere_body = chrono.ChBodyEasySphere(radius, density, True, True, contact_material_ball)
        sphere_body.SetName(f"Ball_3_{i}")
        
        # Arrange spheres in 2 rows of 5
        x = -0.05 + 0.035 * i * (i < 5) + 0.035 * (i - 5) * (i >= 5)
        y = -0.2
        z = -0.05 + 0.1 * (i >= 5)
        sphere_body.SetPos(chrono.ChVectorD(x, y, z))

        # Texture (optional)
        sphere_body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))

        self.m_sys.Add(sphere_body)
        self.m_spheres.append(sphere_body)

  def addRandomSpheres(self):
    if (self.mission_config.add_payload_flag
      and self.mission_config.payload_type == "many_steel_balls_in_random_position"
      ):
      self.m_spheres: list[chrono.ChBody] = []  # Store sphere bodies
      contact_material_ball = chrono.ChMaterialSurfaceNSC()
      radius = 0.015875
      density = 7850
      sphere_number = 10
      for i in range(sphere_number):
        sphere = chrono.ChBodyEasySphere(
          radius,
          density,
          True,   # visualization
          True,   # collision
          contact_material_ball
        )
        sphere.SetName(f"Ball_3_{i}")
        sphere.SetPos(chrono.ChVectorD(
          -0.05 + chrono.ChRandom() * 0.1,
          -0.2  + chrono.ChRandom() * 0.05,
          -0.05 + chrono.ChRandom() * 0.1
        ))
        sphere.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker1.png"))

        self.m_sys.Add(sphere)
        self.m_spheres.append(sphere)

  def addPayload(self):
    self.addTwoSteelBallsPayload()
    self.addSpheresInArrays()
    self.addRandomSpheres()

  def updatePixhawkState(self):
    coord_GLOB = self.marker_pixhawk.GetAbsCoord()
    coord_dt_GLOB = self.marker_pixhawk.GetAbsCoord_dt()
    coord_dtdt_GLOB = self.marker_pixhawk.GetAbsCoord_dtdt()
    Wvel_GLOB = self.marker_pixhawk.GetAbsWvel()
    Wacc_GLOB = self.marker_pixhawk.GetAbsWacc()

    rotmat = chrono.ChMatrix33D(coord_GLOB.rot)
    rotmat_F = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(coord_GLOB.rot)

    pos_LOC = rotmat_F * coord_GLOB.pos
    vel_LOC = rotmat_F * coord_dt_GLOB.pos
    acc_LOC = rotmat_F * coord_dtdt_GLOB.pos
    Wvel_LOC = rotmat_F * Wvel_GLOB
    Wacc_LOC = rotmat_F * Wacc_GLOB

    pos_LOC_to_GLOB = rotmat * pos_LOC
    pos_LOC_to_GLOB_NED = self.RR * pos_LOC_to_GLOB
    vel_LOC_to_GLOB = rotmat * vel_LOC
    vel_LOC_to_GLOB_NED = self.RR * vel_LOC_to_GLOB
    Wvel_LOC_to_GLOB = rotmat * Wvel_LOC
    Wvel_LOC_to_GLOB_NED = self.RR * Wvel_LOC_to_GLOB

    quat = self.marker_pixhawk_2.GetAbsCoord().rot
    quat_fixed = chrono.ChQuaternionD(quat.e0, -quat.e1, -quat.e3, quat.e2)
    rotmat_euler321 = fun.rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_fixed)
    euler321 = fun.euler321_from_rotmat(rotmat_euler321)

    self.pixhawk_state = PixhawkState(
      coord_GLOB=coord_GLOB,
      coord_dt_GLOB=coord_dt_GLOB,
      coord_dtdt_GLOB=coord_dtdt_GLOB,
      Wvel_GLOB=Wvel_GLOB,
      Wacc_GLOB=Wacc_GLOB,
      rotmat=rotmat,
      rotmat_F=rotmat_F,
      pos_LOC=pos_LOC,
      vel_LOC=vel_LOC,
      acc_LOC=acc_LOC,
      Wvel_LOC=Wvel_LOC,
      Wacc_LOC=Wacc_LOC,
      pos_LOC_to_GLOB=pos_LOC_to_GLOB,
      pos_LOC_to_GLOB_NED=pos_LOC_to_GLOB_NED,
      vel_LOC_to_GLOB=vel_LOC_to_GLOB_NED,
      vel_LOC_to_GLOB_NED=vel_LOC_to_GLOB_NED,
      Wvel_LOC_to_GLOB=Wvel_LOC_to_GLOB,
      Wvel_LOC_to_GLOB_NED=Wvel_LOC_to_GLOB_NED,
      quat_fixed=quat_fixed,
      euler321=euler321
    )  

  def getVehicleState(self) -> VehicleState:
    """
    Return the current vehicle state with attitude, position, and velocity data.
    """
    roll = self.pixhawk_state.euler321.x
    pitch = self.pixhawk_state.euler321.y
    yaw = self.pixhawk_state.euler321.z
    translational_position_in_I = np.array(fun.chvector_to_list(self.pixhawk_state.pos_LOC_to_GLOB_NED)).reshape(3,1)
    translational_velocity_in_I = np.array(fun.chvector_to_list(self.pixhawk_state.vel_LOC_to_GLOB_NED)).reshape(3,1)
    angular_velocity = np.array(fun.chvector_to_list(self.pixhawk_state.Wvel_LOC)).reshape(3,1)
    # angular_acceleration = np.array(fun.chvector_to_list(self.pixhawk_state.Wacc_LOC)).reshape(3,1)

    return VehicleState(
      roll=roll,
      pitch=pitch,
      yaw=yaw,
      position_global=translational_position_in_I,
      velocity_global=translational_velocity_in_I,
      angular_velocity_local=angular_velocity
    )
  
  def applyAerodynamicForce(self, flight_params: FlightParams):
    aerodynamic_velocity = np.array(fun.chvector_to_list(self.pixhawk_state.vel_LOC)).reshape(3,1)
    aerodynamic_force = (
      -0.5 * flight_params.uav_controller.air_density_estimated * 
      flight_params.uav_controller.surface_area_estimated * 
      flight_params.uav_controller.drag_coefficient_matrix_estimated * 
      aerodynamic_velocity * LA.norm(aerodynamic_velocity)
    )

    self.m_frame.Accumulate_force(
      chrono.ChVectorD(aerodynamic_force[0].item(), aerodynamic_force[1].item(), aerodynamic_force[2].item()),
      flight_params.uav.aerodynamic_force_application_point,
      True
    )

  def applyWindForce(self, flight_params: FlightParams,
                     wind_force_vector: tuple[float, float, float] = (1.0, 0.0, 0.0),
                     apply: bool = False):
    """
    Apply a constant wind force to the UAV if `apply` is True.

    Args:
        wind_force_vector: A tuple of (x, y, z) wind force components in the global frame.
        apply: Whether or not to apply the wind force.
    """
    if not apply:
      return
    
    self.m_frame.Accumulate_force(
      chrono.ChVectorD(*wind_force_vector), 
      flight_params.uav.aerodynamic_force_application_point, 
      False
    )

  def applyMotorThrustLimitsAndEfficiency(self, controller, flight_params: FlightParams):
    """Clamp motor thrusts to physical limits and apply motor efficiency."""
    # Thrust saturation
    for i in range(len(controller.motor_thrusts)):
      if controller.motor_thrusts[i][0] < flight_params.uav.minimum_motor_thrust:
        # if some component of the thrust force is smaller than the min thrust that can physically
        # be generated set it to flight_params.minimum_motor_thrust
        controller.motor_thrusts[i][0] = flight_params.uav.minimum_motor_thrust 
      if controller.motor_thrusts[i][0] > flight_params.uav.maximum_motor_thrust:
        # if some component of the thrust force is greater than the max thrust that can physically
        # be generated set it to flight_params.maximum_motor_thrust
        controller.motor_thrusts[i][0] = flight_params.uav.maximum_motor_thrust 

    # Accounting for motor efficiency
    controller.motor_thrusts = np.array(flight_params.uav.motor_efficiency_matrix * controller.motor_thrusts)

  # TODO: Generalize for arbitrary number of propellers (DONE!)
  def applyMotorForces(self, controller, flight_params: FlightParams):
    """
    Apply thrust forces from motors at predefined local positions with respect to the drone frame.
    Generalized to support any number of motors/propellers.
    """
    # Get list of predefined force application points from FlightParams
    force_positions = flight_params.uav.motor_force_positions  # List of ChVectorD
    num_positions = len(force_positions)

    # If you have a custom mapping, you can define it in flight_params.uav.motor_index_map
    # Otherwise, assume 1:1 mapping
    if hasattr(flight_params.uav, "motor_index_map"):
      motor_index_map = flight_params.uav.motor_index_map
      if len(motor_index_map) != self.number_of_propellers:
          raise ValueError(f"motor_index_map length ({len(motor_index_map)}) does not match number of motors ({self.number_of_propellers})")
    else:
      motor_index_map = list(range(self.number_of_propellers))
      
    for i, motor_idx in enumerate(motor_index_map):
      thrust_value = controller.motor_thrusts[motor_idx][0]
      force_vec = chrono.ChVectorD(0, thrust_value, 0)
      # force_vec = chrono.ChVectorD(0, 0, 0) # For debugging

      # Pick the position corresponding to this motor
      # If fewer positions are defined (e.g., symmetrical pairs), cycle through them
      force_pos = force_positions[i % num_positions]
      # print(f"\n[DEBUG] Applying thrust {thrust_value} at position {force_pos} for motor {motor_idx}\nForce vector: {force_vec}") ############################################################################################################

      # Apply physical force
      self.m_frame.Accumulate_force(force_vec, force_pos, True)

  def applyPropellerReactionTorques(self, controller, flight_params: FlightParams):
    """
    Computes and applies the individual reaction torques generated by each of the n propellers
    based on their angular velocities and spin direction.
    """
    # Compute angular velocities for each motor
    self.omega = np.sqrt(controller.motor_thrusts / flight_params.uav_controller.K_omega)

     # Compute and apply torques
    for i in range(self.number_of_propellers):
      omega_squared = self.omega[i][0] ** 2
      torque_y = flight_params.uav.propellers_spin_directions[i] * omega_squared * flight_params.uav_controller.K_torque
      torque = chrono.ChVectorD(0, torque_y, 0)
      self.m_frame.Accumulate_torque(torque, True)

  def setPropellerRotationalVelocity(self, flight_params: FlightParams):
    """
    Sets the rotational velocity for each propeller motor link,
    based on the signed angular velocities.
    """
    # Simulate the rotation of the propellers only if a CAD model was provided
    if self.m_motors != []:
      # Compute the signed angular velocities
      omega_signed = [
          flight_params.uav.propellers_spin_directions[i] * self.omega[i][0]
          for i in range(self.number_of_propellers)
      ]

      reducing_factor = 10.0  # To slow down the visualization of the propellers
      for i in range(self.number_of_propellers):
        omega_reduced = omega_signed[i] / reducing_factor
        self.m_motors[i].SetMotorFunction(chrono.ChFunction_Const(omega_reduced))

  def handlePayloadDroppingBalls12(self, time_now: float,
                                   apply: bool=False, 
                                   drop_time: float=3.7,        # Time at which payloads should be dropped.
                                   disable_duration: float=0.15 # Time duration for which collisions are disabled after the drop.
                                   ): 
    """
    Temporarily disables and then re-enables collisions for the payloads to simulate dropping them if `apply` is True.

    Parameters:
    - time_now (float):         The current simulation time.
    - apply (bool):             Whether or not to apply the payload dropping.
    - drop_time (float):        Time at which payloads should be dropped.
    - disable_duration (float): Time duration for which collisions are disabled after the drop.
    """
    if not apply:
      return
    
    if (self.mission_config.add_payload_flag and self.mission_config.payload_type == "two_steel_balls"):

      if (time_now > drop_time):
        self.m_ball1.SetCollide(False)
        self.m_ball2.SetCollide(False) 
      if (time_now > (drop_time + disable_duration)):
        self.m_ball1.SetCollide(True)
        self.m_ball2.SetCollide(True)

  def handleMotorFailure(self, time_now: float, flight_params: FlightParams, apply: bool=False, failure_time: float=4.5):
    """
    Modifies the motor efficiency matrix that simulates motor failure after a given time.

    Parameters:
    - time_now (float):     The current simulation time.
    - apply (bool):         Whether or not to apply the motor failure.
    - failure_time (float): Time at which the motor failure occurs.
    """
    if not apply:
      return

    
    if (time_now > failure_time):
      flight_params.uav.motor_efficiency_matrix = flight_params.uav.motor_efficiency_matrix_after_failure

  def sequentiallyDropBalls(self, time_now: float,
                            apply: bool = False,
                            drop_start_time: float=3.0,     # Time at which the first ball starts dropping
                            drop_interval: float=0.10,      # Time delay between successive ball drops
                            disable_duration: float=0.15    # How long each ball should stay non-collidable
                            ):
    """
    Toggles collision state of balls one by one to simulate sequential payload dropping.

    Parameters:
    - time_now (float):         Current simulation time.
    - apply (bool):             Whether or not to apply the payload dropping.
    - drop_start_time (float):  Time at which the first ball starts dropping
    - drop_interval (float):    Time delay between successive ball drops.
    - disable_duration (float): How long each ball should stay non-collidable
    """
    if not apply:
      return

    if (self.mission_config.add_payload_flag and self.mission_config.payload_type != "two_steel_balls"):

      if not hasattr(self, "m_spheres") or len(self.m_spheres) == 0:
        return  # No spheres to drop
      
      for i, ball in enumerate(self.m_spheres):
        drop_time_i = drop_start_time + i * drop_interval
        reenable_time_i = drop_time_i + disable_duration

        if time_now < drop_time_i:
          # Ball hasn't dropped yet — keep collision on
          ball.SetCollide(True)
        elif drop_time_i <= time_now < reenable_time_i:
          # Ball is in its disabled phase — collision off
          ball.SetCollide(False)
        else:
          # Disable duration passed — re-enable collision
          ball.SetCollide(True)

  def assignInstances(
    self,
    flight_params: FlightParams,
    ode_input: OdeInput,
    user_defined_trajectory: Traj.BaseUserDefinedTrajectory,
    gains,
    controller: Control,
    logger
    ):

    self.flight_params = flight_params
    self.ode_input = ode_input
    self.user_defined_trajectory = user_defined_trajectory
    self.gains = gains
    self.controller = controller
    self.logger = logger

  def runSimulationLoop(self):
    self.visualization.setup()
    start_sim_time = time.time() # Time acquired in order to measure the execution time of the simulation

    # Simulation loop
    while self.m_sys.GetChTime() < self.mission_config.simulation_duration_seconds:
      if not self.visualization.update():
        break # Exit loop if visualization window is closed

      self.stepSimulation(start_sim_time)

  def stepSimulation(self, start_sim_time: float):
    self.m_sys.DoStepDynamics(self.mission_config.timestep)
    # Empty_forces_accumulators() MUST be used in conjunction with 
    # Accumulate_force() and Accumulate_torque() used to apply forces and torques
    self.m_frame.Empty_forces_accumulators()

    time_now = self.m_sys.GetChTime() # Time "inside" the simulation
    simulation_time = time.time() - start_sim_time # Time that the simulation is taking

    self.updateSystemStates(time_now)
    self.applyExternalForces(self.mission_config)
    self.handlePayloadMechanisms(time_now, self.mission_config)
    self.handleFaults(time_now, self.mission_config)
    self.runControllerIfStarted(time_now, simulation_time)

    self.debugPrints(time_now, simulation_time)

  def updateSystemStates(self, time_now: float):
    # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
    self.updateCOMcomputationOfSystemWithPayload()
    self.updatePixhawkState()
    # Compute user-defined trajectory
    user_defined_trajectory_state = self.user_defined_trajectory.compute(time_now)
    # Collect vehicle state
    vehicle_state = self.getVehicleState()
    # Collect together inputs to be sent to the controller
    self.ode_input.update(
      time_now,
      vehicle_state,
      user_defined_trajectory_state
    )
  
  def applyExternalForces(self, mission_config: Cfg.MissionConfig):
    # Applying AERODYNAMIC FORCE to the drone
    self.applyAerodynamicForce(self.flight_params)
    # Applying a constant WIND FORCE to the drone, expressed in pychrono global coordinate
    self.applyWindForce(self.flight_params, wind_force_vector=mission_config.wind_force_vector, apply=mission_config.apply_wind_force)

  def runControllerIfStarted(self, time_now: float, simulation_time: float):
    if time_now <= self.flight_params.controller_start_time:
      return

    # Execute the control algorithm
    self.controller.run(self.ode_input)

    # Thrust saturation
    self.applyMotorThrustLimitsAndEfficiency(self.controller, self.flight_params)
    # Applying motor thrust forces
    self.applyMotorForces(self.controller, self.flight_params)
    # Apply propellers reaction torques around local yaw-axis
    self.applyPropellerReactionTorques(self.controller, self.flight_params)
    # Setting the propeller rotational velocities
    self.setPropellerRotationalVelocity(self.flight_params)

    # Collect the log data
    self.logger.collectData(self.controller, simulation_time, self.number_of_propellers)

  def handlePayloadMechanisms(self, time_now: float, mission_config: Cfg.MissionConfig):
    # Payload Dropping
    self.handlePayloadDroppingBalls12(time_now, apply=mission_config.drop_two_steel_balls, drop_time=mission_config.two_steel_balls_drop_time)
    # Dropping multiple balls one after the other
    self.sequentiallyDropBalls(time_now,
                               apply=mission_config.sequentially_drop_multiple_balls,
                               drop_start_time=mission_config.sequentially_drop_start_time,
                               drop_interval=mission_config.sequentially_drop_interval)

  def handleFaults(self, time_now: float, mission_config: Cfg.MissionConfig):
    # Motor failure
    self.handleMotorFailure(time_now, self.flight_params, apply=mission_config.apply_motor_failure, failure_time=mission_config.motor_failure_time)

  def debugPrints(self, time_now: float, simulation_time: float):
    # Print data to Console
    Utils.printSimulationTimeInline(
      'Simulation time', time_now,
      'Time the simulation is taking', simulation_time
    )
    # print("m_ball1.GetMass(): ", self.m_ball1.GetMass())
    Utils.printControllerDebugInfo(
      self.controller, time_now, self.flight_params,
      print_console_flag=False
    )












  




